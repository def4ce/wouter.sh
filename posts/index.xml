<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Wouter in &#39;t Veld</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Wouter in &#39;t Veld</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Wouter in &#39;t Veld</copyright>
        <lastBuildDate>Sun, 14 Jul 2019 00:00:00 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Disable SSH on your EC2 instances</title>
            <link>/posts/professional/aws-disable-ssh/</link>
            <pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate>
            
            <guid>/posts/professional/aws-disable-ssh/</guid>
            <description>If you have to SSH into your servers, then your automation has failed.
I know, crazy&amp;hellip;
To make the transition to this mindset easier you could just disable access to port 22 in your instance security group configuration. This will highlight the things you still need to automate while still have the ability to enable access your instances to remedy immediate operational issues.
Disabling inbound SSH will stop you from cheating.</description>
            <content type="html"><![CDATA[<p><strong>If you have to SSH into your servers, then your automation has failed</strong>.</p>

<p>I know, crazy&hellip;</p>

<p>To make the transition to this mindset easier you could just disable access to port 22 in your instance security group configuration. This will highlight the things you still need to automate while still have the ability to enable access your instances to remedy immediate operational issues.</p>

<p>Disabling inbound SSH will stop you from cheating. You can&rsquo;t just log in and quickly fix the issue. You have to re-enable access to do this and hopefully this will become annoying enouight to force you to get your automation in order.</p>

<p>This is both a frightening and yet useful thing I&rsquo;ve learned while doing automation in AWS.</p>

<p>as a note: <code>If your application relies on being able to push to a server via SSH, then disabling it might be a bad idea.</code></p>
]]></content>
        </item>
        
        <item>
            <title>Setting up an SSH server as a proxy</title>
            <link>/posts/professional/setting-up-ssh-server-proxy/</link>
            <pubDate>Sat, 09 Sep 2017 00:00:00 +0000</pubDate>
            
            <guid>/posts/professional/setting-up-ssh-server-proxy/</guid>
            <description>Recently I setup an SSH server at home. This allows me, besides the obvious, to create an SSH tunnel to encrypt my connections and circumvent restrictions. This is particularly useful on public Wi-Fi networks. These networks may block certain services and other people using the network might be less friendly.
Installing Your Linux server most likely already has openssh-server installed. If it hasn&amp;rsquo;t, installing SSH server is easy. Because I use CentOS the examples will reflect that.</description>
            <content type="html"><![CDATA[

<p>Recently I setup an SSH server at home. This allows me, besides the obvious, to create an SSH tunnel to encrypt my connections and circumvent restrictions. This is particularly useful on public Wi-Fi networks. These networks may block certain services and other people using the network might be <a href="http://lifehacker.com/5906233/do-i-really-need-to-be-that-worried-about-security-when-im-using-public-wi-fi" target="_blank">less</a> friendly.</p>

<h3 id="installing">Installing</h3>

<p>Your Linux server most likely already has openssh-server installed. If it hasn&rsquo;t,
installing SSH server is easy. Because I use CentOS the examples will reflect that.</p>

<pre><code class="language-bash">$ sudo yum -y install openssh-server
</code></pre>

<p>Start the sshd service:</p>

<pre><code class="language-bash">$ sudo systemctl start sshd
</code></pre>

<p>Making sure it starts when the machine boots</p>

<pre><code class="language-bash">$ sudo systemctl enable sshd
Created symlink from /etc/systemd/system/multi-user.target.wants/sshd.service to /usr/lib/systemd/system/sshd.service.
</code></pre>

<p>Verifying the above:</p>

<pre><code class="language-bash">$ systemctl status sshd
● sshd.service - OpenSSH server daemon
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
   Active: active (running) since za 2017-09-09 18:18:35 UTC; 4s ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 2413 (sshd)
   CGroup: /system.slice/sshd.service
           └─2413 /usr/sbin/sshd -D -u0

sep 09 18:18:35 localhost.localdomain systemd[1]: Starting OpenSSH server daemon...
sep 09 18:18:35 localhost.localdomain sshd[2413]: Server listening on 0.0.0.0 port 22.
sep 09 18:18:35 localhost.localdomain sshd[2413]: Server listening on :: port 22.
sep 09 18:18:35 localhost.localdomain systemd[1]: Started OpenSSH server daemon.
</code></pre>

<p>That&rsquo;s it. As a note, if you previously setup firewall rules to block incoming connections make sure to allow incoming traffic on port 22. I will post the iptables rules that I use in a moment.</p>

<h3 id="configure-sshd">Configure sshd</h3>

<p>Before editing <code>/etc/ssh/sshd_config</code> we need to generate an SSH key. Github has a good <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank">tutorial</a> on this. Follow it to setup your SSH key. Use a different key for every machine that is going to connect to your SSH service. Once setup you can copy the key to the server with:</p>

<pre><code class="language-bash">$ ssh-copy-id wouter@server
</code></pre>

<p>Replace <code>server</code> with the hostname or ipadress of your ssh server and <code>user</code> with your user. You will be prompted to login with your password before the key gets copied. When the process is finished try logging in again to verify if it&rsquo;s working. Please refer to the Github <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank">tutorial</a> if you run in to problems.</p>

<p>There are some configuration settings you can apply that harden your ssh service. Use your favourite editor to edit <code>/etc/ssh/sshd_config</code>, I use vi.</p>

<pre><code class="language-bash">$ sudo vi /etc/ssh/sshd_config
</code></pre>

<p>Add, edit or uncomment</p>

<pre><code>PubkeyAuthentication yes
PasswordAuthentication no
ChallengeResponseAuthentication no
AllowTcpForwarding yes
</code></pre>

<p>This will <em>disable</em> password authentication, one-way-authentication and <em>enables</em> public key authentication and traffic forwarding. Keys are easily managed, unsniffable and uncrackable. The same can&rsquo;t be said about passwords.</p>

<p>The next one is up for discussion, allowing root access. Personally I disallow it, but <code>PermitRootLogin without-password</code> is a safe setting. This means <code>root</code> can only login with public key authentication. As mentioned, I&rsquo;ve set it to <code>PermitRootLogin no</code></p>

<p>Another good practice is to use a non-standard port for your ssh service. I haven&rsquo;t done it but this will significantly reduce the amount login tries from scriptkiddies. When choosing a port, have a look at what services <a href="https://nmap.org/" target="_blank">nmap</a> scans for on a default port scan.
To change to another port edit <code>/etc/ssh/sshd_config</code>:</p>

<pre><code>Port 12345
</code></pre>

<p>Save your changes and verify the SSH configuration</p>

<pre><code class="language-bash">$ sudo sshd -t
</code></pre>

<p>This should return no errors. When it doesn&rsquo;t you can restart the SSH daemon</p>

<pre><code class="language-bash">$ sudo systemctl restart sshd
</code></pre>

<p>The new configuration is now active.</p>

<h3 id="setting-up-iptables">Setting up iptables</h3>

<p>Since I run my ssh service on the default port I am a target for <a href="https://en.wikipedia.org/wiki/Script_kiddie" target="_blank">scriptkiddies</a> trying to gain access to my machine. And since I want to tunnel my traffic when on public Wi-Fi I can&rsquo;t scope the access down to a few IP&rsquo;s.</p>

<p>CentOS comes with <code>firwalld</code>. I don&rsquo;t like <code>firewalld</code> so I disable it.</p>

<pre><code class="language-bash">$ sudo systemctl stop firewalld
$ sudo systemctl disable firewalld
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.
$ sudo systemctl mask firewalld
Created symlink from /etc/systemd/system/firewalld.service to /dev/null.
</code></pre>

<p>Disabling the service deletes the symlink, so the unit file itself is not affected, but the service is not loaded at the next boot, when systemd reads /etc/systemd/system.</p>

<p>However, a disabled service can be loaded, and will be started if a service that depends on it is started; enable and disable only configure auto-start behaviour for units, and the state is easily overridden.</p>

<p>A masked service is one whose unit file is a symlink to /dev/null. This makes it &ldquo;impossible&rdquo; to load the service, even if it is required by another, enabled service.</p>

<p>When you mask a service, a symlink is created from /etc/systemd/system to /dev/null, leaving the original unit file elsewhere untouched. When you unmask a service the symlink is deleted.</p>

<p>With <code>firewalld</code> out of the way, I can apply my iptables script to setup the firewall.</p>

<pre><code class="language-bash">#!/bin/bash
iptables -F                     # flush rules
iptables -X                     # delete user added chains
iptables -P FORWARD DROP        # drop forwarding
iptables -P INPUT DROP          # drop incoming
iptables -P OUTPUT ACCEPT       # allow outgoing

# define custom chains
iptables -N ssh_init
iptables -N ssh_throttle

iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT # accept previously allowed traffic
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP # invalid packets get dropped
iptables -A INPUT -i lo -j ACCEPT # allow all traffic on the loopback interface

# ssh init
iptables -A INPUT -s 0/0 -p tcp --dport 22 --syn -j ssh_init
iptables -A ssh_init -m recent --name ssh_input_trap --rcheck --seconds 60 --hitcount 3 --rttl -j DROP
iptables -A ssh_init -m recent --name ssh_input_trap --set -j RETURN

# ssh throttle
iptables -A INPUT -s 0/0 -p tcp --dport 22 --syn -j ssh_throttle
iptables -A ssh_throttle -m connlimit --connlimit-above 3 -j DROP
iptables -A ssh_throttle -m limit --limit 3/m --limit-burst 1 -j ACCEPT

</code></pre>

<p>To make the rules persistent you need the <code>iptables-services</code> package since we disabled <code>firewalld</code>.</p>

<pre><code class="language-bash">$ yum -y install iptables-services
</code></pre>

<p>After installation you can run</p>

<pre><code class="language-bash">$ sudo service iptables save
</code></pre>

<blockquote>
<p>note: If you run <code>docker</code> restart the docker service first before saving the rules. This will recreate the docker iptables rules</p>
</blockquote>

<p>These rules set the policy to drop all incoming packets except for the SYN packet on port 22. A SYN starts a connection, you&rsquo;ll usually only see it when the connection&rsquo;s being established. When someone sends three SYN packets in a minute, they get dropped. When they make more than three connections in a minute, they will get dropped. When the SYN is accepted a connection is established and the traffic will be allowed.</p>

<p>With these rules in place we can start using our SSH service.</p>

<h3 id="setting-up-an-ssh-tunnel">Setting up an SSH tunnel</h3>

<pre><code class="language-bash">$ ssh -D 3000 -f -C -q -N wouter@miles
</code></pre>

<p>Let see what this command does.<br />
<code>-D 3000</code> This allocates a socket to listen on port 3000.<br />
<code>-f</code> Requests ssh to go to background just before command execution.<br />
<code>-C</code> Requests compression of all data.<br />
<code>-q</code> Quiet mode.<br />
<code>-N</code> Do not execute a remote command.<br />
<code>wouter@miles</code> user and the server.</p>

<p>With the tunnel up and running you need configure your browser to use it. In <code>Firefox</code> go to <code>preferences &gt; advanced &gt; network</code> and tick <code>manual proxy configuration</code>. Next set the <code>SOCKS Host</code> to <code>localhost</code> and <code>port</code> to <code>3000</code>. Also tick the <code>proxy dns when using socks5</code> box. <code>Firefox</code> is now ready to use the tunnel.</p>
]]></content>
        </item>
        
    </channel>
</rss>
